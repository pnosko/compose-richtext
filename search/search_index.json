{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 Compose Richtext is a collection of Compose libraries for working with rich text formatting and documents. richtext-ui , richtext-commonmark , and richtext-material-ui are Kotlin Multiplatform(KMP) Compose Libraries. All 3 of these modules can be used in Android and Desktop Compose apps. Each library is documented separately, see the navigation menu for the list. This site also includes an API reference. Warning This project is currently experimental and mostly just a proof-of-concept at this point. There are no tests and some things might be broken or very non-performant. The API may also change between releases without deprecation cycles. Getting started \u00b6 These libraries are published to Maven Central, so just add a Gradle dependency: dependencies { implementation \"com.halilibo.compose-richtext:<LIBRARY-ARTIFACT>:${richtext_version}\" } There is no difference for KMP artifacts. For instance, if you are adding richtext-ui to a Kotlin Multiplatform module val commonMain by getting { dependencies { implementation ( \"com.halilibo.compose-richtext:richtext-ui: ${ richtext_version } \" ) } } Library Artifacts \u00b6 The LIBRARY_ARTIFACT s for each individual library can be found on their respective pages. Samples \u00b6 Please check out Android and Desktop projects to see various use cases of RichText in both platforms.","title":"Overview"},{"location":"#overview","text":"Compose Richtext is a collection of Compose libraries for working with rich text formatting and documents. richtext-ui , richtext-commonmark , and richtext-material-ui are Kotlin Multiplatform(KMP) Compose Libraries. All 3 of these modules can be used in Android and Desktop Compose apps. Each library is documented separately, see the navigation menu for the list. This site also includes an API reference. Warning This project is currently experimental and mostly just a proof-of-concept at this point. There are no tests and some things might be broken or very non-performant. The API may also change between releases without deprecation cycles.","title":"Overview"},{"location":"#getting-started","text":"These libraries are published to Maven Central, so just add a Gradle dependency: dependencies { implementation \"com.halilibo.compose-richtext:<LIBRARY-ARTIFACT>:${richtext_version}\" } There is no difference for KMP artifacts. For instance, if you are adding richtext-ui to a Kotlin Multiplatform module val commonMain by getting { dependencies { implementation ( \"com.halilibo.compose-richtext:richtext-ui: ${ richtext_version } \" ) } }","title":"Getting started"},{"location":"#library-artifacts","text":"The LIBRARY_ARTIFACT s for each individual library can be found on their respective pages.","title":"Library Artifacts"},{"location":"#samples","text":"Please check out Android and Desktop projects to see various use cases of RichText in both platforms.","title":"Samples"},{"location":"printing/","text":"Printing \u00b6 A library for using Compose to generated printed documents, using Android's printing services. Gradle \u00b6 dependencies { implementation \"com.halilibo.compose-richtext:printing:${richtext_version}\" } Usage \u00b6 There are multiple entry points into this library. See their kdoc for usage and parameter documentation, and take a look at the samples for example code. Printable \u00b6 This is the simplest entry point. It's a composable function that displays its children on screen, but can also print itself. Printing is triggered by the PrintableController passed to Printable . PrintableController is a hoisted state type, just like ScrollState , created by calling rememberPrintableController . val printController = rememberPrintableController () Printable ( printController ) { ScrollableColumn { Card { \u2026 } Card { \u2026 } Button ( onClick = { printController . print ( \"sales report\" ) }) { \u2026 } } } ComposePrintAdapter \u00b6 This is a PrintDocumentAdapter that can be used directly with Android's printing APIs to print any composable function. It takes, at minimum, the ComponentActivity that owns the print adapter (as required by Android's printing framework), a string name for the document, and the composable function that defines the content to print. See the linked API documentation for more details. Paged \u00b6 This is another composable, but doesn't actually have anything to do with printing. Conceptually it's similar to a ScrollableColumn \u2013 it lays its contents out at full height, then can display them at various vertical offsets. However, it also tries to ensure that no composables are clipped at the bottom, by measuring where all the leaf composables (those without any children) are located clipping the content before them. It is used by the printing APIs to try to ensure that composable content looks decent when split into printer pages. See the PagedSample for more information. Demo \u00b6 The DocumentSample tries to match the style of one of the Google Docs templates. It looks great on small phone screens, but also prints:","title":"Printing"},{"location":"printing/#printing","text":"A library for using Compose to generated printed documents, using Android's printing services.","title":"Printing"},{"location":"printing/#gradle","text":"dependencies { implementation \"com.halilibo.compose-richtext:printing:${richtext_version}\" }","title":"Gradle"},{"location":"printing/#usage","text":"There are multiple entry points into this library. See their kdoc for usage and parameter documentation, and take a look at the samples for example code.","title":"Usage"},{"location":"printing/#printable","text":"This is the simplest entry point. It's a composable function that displays its children on screen, but can also print itself. Printing is triggered by the PrintableController passed to Printable . PrintableController is a hoisted state type, just like ScrollState , created by calling rememberPrintableController . val printController = rememberPrintableController () Printable ( printController ) { ScrollableColumn { Card { \u2026 } Card { \u2026 } Button ( onClick = { printController . print ( \"sales report\" ) }) { \u2026 } } }","title":"Printable"},{"location":"printing/#composeprintadapter","text":"This is a PrintDocumentAdapter that can be used directly with Android's printing APIs to print any composable function. It takes, at minimum, the ComponentActivity that owns the print adapter (as required by Android's printing framework), a string name for the document, and the composable function that defines the content to print. See the linked API documentation for more details.","title":"ComposePrintAdapter"},{"location":"printing/#paged","text":"This is another composable, but doesn't actually have anything to do with printing. Conceptually it's similar to a ScrollableColumn \u2013 it lays its contents out at full height, then can display them at various vertical offsets. However, it also tries to ensure that no composables are clipped at the bottom, by measuring where all the leaf composables (those without any children) are located clipping the content before them. It is used by the printing APIs to try to ensure that composable content looks decent when split into printer pages. See the PagedSample for more information.","title":"Paged"},{"location":"printing/#demo","text":"The DocumentSample tries to match the style of one of the Google Docs templates. It looks great on small phone screens, but also prints:","title":"Demo"},{"location":"richtext-commonmark/","text":"Markdown \u00b6 Library for rendering Markdown in Compose using CommonMark library/spec to parse, and richtext-ui to render. Gradle \u00b6 dependencies { implementation \"com.halilibo.compose-richtext:richtext-commonmark:${richtext_version}\" } Usage \u00b6 The simplest way to render markdown is just pass a string to the Markdown composable under RichText scope: Warning Markdown composable has recently changed to be an extension on RichTextScope instead of being a separate entry composable. RichText ( modifier = Modifier . padding ( 16. dp ) ) { Markdown ( \"\"\" # Demo Emphasis, aka italics, with *asterisks* or _underscores_. Strong emphasis, aka bold, with **asterisks** or __underscores__. Combined emphasis with **asterisks and _underscores_**. [Links with two blocks, text in square-brackets, destination is in parentheses.](https://www.example.com). Inline `code` has `back-ticks around` it. 1. First ordered list item 2. Another item * Unordered sub-list. 3. And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). * Unordered list can use asterisks - Or minuses + Or pluses --- ```javascript var s = \"code blocks use monospace font\"; alert(s); ``` Markdown | Table | Extension --- | --- | --- *renders* | `beautiful images` | ![random image](https://picsum.photos/seed/picsum/400/400 \"Text 1\") 1 | 2 | 3 > Blockquotes are very handy in email to emulate reply text. > This line is part of the same quote. \"\"\" . trimIndent () ) } Which produces something like this:","title":"Markdown"},{"location":"richtext-commonmark/#markdown","text":"Library for rendering Markdown in Compose using CommonMark library/spec to parse, and richtext-ui to render.","title":"Markdown"},{"location":"richtext-commonmark/#gradle","text":"dependencies { implementation \"com.halilibo.compose-richtext:richtext-commonmark:${richtext_version}\" }","title":"Gradle"},{"location":"richtext-commonmark/#usage","text":"The simplest way to render markdown is just pass a string to the Markdown composable under RichText scope: Warning Markdown composable has recently changed to be an extension on RichTextScope instead of being a separate entry composable. RichText ( modifier = Modifier . padding ( 16. dp ) ) { Markdown ( \"\"\" # Demo Emphasis, aka italics, with *asterisks* or _underscores_. Strong emphasis, aka bold, with **asterisks** or __underscores__. Combined emphasis with **asterisks and _underscores_**. [Links with two blocks, text in square-brackets, destination is in parentheses.](https://www.example.com). Inline `code` has `back-ticks around` it. 1. First ordered list item 2. Another item * Unordered sub-list. 3. And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). * Unordered list can use asterisks - Or minuses + Or pluses --- ```javascript var s = \"code blocks use monospace font\"; alert(s); ``` Markdown | Table | Extension --- | --- | --- *renders* | `beautiful images` | ![random image](https://picsum.photos/seed/picsum/400/400 \"Text 1\") 1 | 2 | 3 > Blockquotes are very handy in email to emulate reply text. > This line is part of the same quote. \"\"\" . trimIndent () ) } Which produces something like this:","title":"Usage"},{"location":"richtext-ui-material/","text":"Richtext UI Material \u00b6 Library that makes RichText compatible with Material design in Compose. Gradle \u00b6 dependencies { implementation \"com.halilibo.compose-richtext:richtext-ui-material:${richtext_version}\" } Usage \u00b6 Material RichText library offers 2 different ways of integrating Material design with RichText in your app. MaterialRichText \u00b6 MaterialRichText composable wraps around regular RichText while introducing the necessary integration dependencies. MaterialRichText shares the exact arguments with regular RichText . MaterialRichText ( modifier = Modifier . background ( color = Color . White )) { Heading ( 0 , \"Paragraphs\" ) Text ( \"Simple paragraph.\" ) ... } SetupMaterialRichText \u00b6 If the whole application is written in Compose or contains large Compose trees, it would be ideal to call this function right after applying the Material Theme. Then, calling MaterialRichText or RichText would have no difference. MaterialTheme (...) { SetupMaterialRichText { RichText ( modifier = Modifier . background ( color = Color . White )) { Heading ( 0 , \"Paragraphs\" ) Text ( \"Simple paragraph.\" ) ... } } }","title":"Richtext UI Material"},{"location":"richtext-ui-material/#richtext-ui-material","text":"Library that makes RichText compatible with Material design in Compose.","title":"Richtext UI Material"},{"location":"richtext-ui-material/#gradle","text":"dependencies { implementation \"com.halilibo.compose-richtext:richtext-ui-material:${richtext_version}\" }","title":"Gradle"},{"location":"richtext-ui-material/#usage","text":"Material RichText library offers 2 different ways of integrating Material design with RichText in your app.","title":"Usage"},{"location":"richtext-ui-material/#materialrichtext","text":"MaterialRichText composable wraps around regular RichText while introducing the necessary integration dependencies. MaterialRichText shares the exact arguments with regular RichText . MaterialRichText ( modifier = Modifier . background ( color = Color . White )) { Heading ( 0 , \"Paragraphs\" ) Text ( \"Simple paragraph.\" ) ... }","title":"MaterialRichText"},{"location":"richtext-ui-material/#setupmaterialrichtext","text":"If the whole application is written in Compose or contains large Compose trees, it would be ideal to call this function right after applying the Material Theme. Then, calling MaterialRichText or RichText would have no difference. MaterialTheme (...) { SetupMaterialRichText { RichText ( modifier = Modifier . background ( color = Color . White )) { Heading ( 0 , \"Paragraphs\" ) Text ( \"Simple paragraph.\" ) ... } } }","title":"SetupMaterialRichText"},{"location":"richtext-ui/","text":"Richtext UI \u00b6 A library of composables for formatting text using higher-level concepts than are supported by compose foundation, such as \"bullet lists\" and \"headings\". RichText UI is a base library that is non-opinionated about higher level design requirements. If you are already using MaterialTheme in your compose app, you can jump to RichText UI Material for quick start. Gradle \u00b6 dependencies { implementation \"com.halilibo.compose-richtext:richtext-ui:${richtext_version}\" } RichText \u00b6 Richtext UI does not depend on Material artifact of Compose. Design agnostic API allows anyone to adopt RichText UI and its extensions like Markdown to their own design and typography systems. If you are planning to adopt RichText within your design system, please go ahead and check out RichText Material for inspiration. RichTextScope \u00b6 RichTextScope is a context wrapper around composables that integrate and play well within RichText content. RichTextThemeIntegration \u00b6 Entry point for integrating app's own typography and theme system with RichText. API for this integration is highly influenced by how compose-material theming is designed. RichText library assumes that almost all Theme/Design systems would have composition locals that provide a TextStyle downstream. Moreover, text style should not include text color by best practice. Content color exists to figure out text color in the current context. Light/Dark theming leverages content color to influence not just text but other parts of theming as well. Example \u00b6 Open the Demo.kt file in the sample module to play with this. Although the mentioned demo uses Material integrated version of RichText , they share exactly the same API. RichText ( modifier = Modifier . background ( color = Color . White ) ) { Heading ( 0 , \"Paragraphs\" ) Text ( \"Simple paragraph.\" ) Text ( \"Paragraph with\\nmultiple lines.\" ) Text ( \"Paragraph with really long line that should be getting wrapped.\" ) Heading ( 0 , \"Lists\" ) Heading ( 1 , \"Unordered\" ) ListDemo ( listType = Unordered ) Heading ( 1 , \"Ordered\" ) ListDemo ( listType = Ordered ) Heading ( 0 , \"Horizontal Line\" ) Text ( \"Above line\" ) HorizontalRule () Text ( \"Below line\" ) Heading ( 0 , \"Code Block\" ) CodeBlock ( \"\"\" { \"Hello\": \"world!\" } \"\"\" . trimIndent () ) Heading ( 0 , \"Block Quote\" ) BlockQuote { Text ( \"These paragraphs are quoted.\" ) Text ( \"More text.\" ) BlockQuote { Text ( \"Nested block quote.\" ) } } Heading ( 0 , \"Info Panel\" ) InfoPanel ( InfoPanelType . Primary , \"Only text primary info panel\" ) InfoPanel ( InfoPanelType . Success ) { Column { Text ( \"Successfully sent some data\" ) HorizontalRule () BlockQuote { Text ( \"This is a quote\" ) } } } Heading ( 0 , \"Table\" ) Table ( headerRow = { cell { Text ( \"Column 1\" ) } cell { Text ( \"Column 2\" ) } }) { row { cell { Text ( \"Hello\" ) } cell { CodeBlock ( \"Foo bar\" ) } } row { cell { BlockQuote { Text ( \"Stuff\" ) } } cell { Text ( \"Hello world this is a really long line that is going to wrap hopefully\" ) } } } } Looks like this:","title":"Richtext UI"},{"location":"richtext-ui/#richtext-ui","text":"A library of composables for formatting text using higher-level concepts than are supported by compose foundation, such as \"bullet lists\" and \"headings\". RichText UI is a base library that is non-opinionated about higher level design requirements. If you are already using MaterialTheme in your compose app, you can jump to RichText UI Material for quick start.","title":"Richtext UI"},{"location":"richtext-ui/#gradle","text":"dependencies { implementation \"com.halilibo.compose-richtext:richtext-ui:${richtext_version}\" }","title":"Gradle"},{"location":"richtext-ui/#richtext","text":"Richtext UI does not depend on Material artifact of Compose. Design agnostic API allows anyone to adopt RichText UI and its extensions like Markdown to their own design and typography systems. If you are planning to adopt RichText within your design system, please go ahead and check out RichText Material for inspiration.","title":"RichText"},{"location":"richtext-ui/#richtextscope","text":"RichTextScope is a context wrapper around composables that integrate and play well within RichText content.","title":"RichTextScope"},{"location":"richtext-ui/#richtextthemeintegration","text":"Entry point for integrating app's own typography and theme system with RichText. API for this integration is highly influenced by how compose-material theming is designed. RichText library assumes that almost all Theme/Design systems would have composition locals that provide a TextStyle downstream. Moreover, text style should not include text color by best practice. Content color exists to figure out text color in the current context. Light/Dark theming leverages content color to influence not just text but other parts of theming as well.","title":"RichTextThemeIntegration"},{"location":"richtext-ui/#example","text":"Open the Demo.kt file in the sample module to play with this. Although the mentioned demo uses Material integrated version of RichText , they share exactly the same API. RichText ( modifier = Modifier . background ( color = Color . White ) ) { Heading ( 0 , \"Paragraphs\" ) Text ( \"Simple paragraph.\" ) Text ( \"Paragraph with\\nmultiple lines.\" ) Text ( \"Paragraph with really long line that should be getting wrapped.\" ) Heading ( 0 , \"Lists\" ) Heading ( 1 , \"Unordered\" ) ListDemo ( listType = Unordered ) Heading ( 1 , \"Ordered\" ) ListDemo ( listType = Ordered ) Heading ( 0 , \"Horizontal Line\" ) Text ( \"Above line\" ) HorizontalRule () Text ( \"Below line\" ) Heading ( 0 , \"Code Block\" ) CodeBlock ( \"\"\" { \"Hello\": \"world!\" } \"\"\" . trimIndent () ) Heading ( 0 , \"Block Quote\" ) BlockQuote { Text ( \"These paragraphs are quoted.\" ) Text ( \"More text.\" ) BlockQuote { Text ( \"Nested block quote.\" ) } } Heading ( 0 , \"Info Panel\" ) InfoPanel ( InfoPanelType . Primary , \"Only text primary info panel\" ) InfoPanel ( InfoPanelType . Success ) { Column { Text ( \"Successfully sent some data\" ) HorizontalRule () BlockQuote { Text ( \"This is a quote\" ) } } } Heading ( 0 , \"Table\" ) Table ( headerRow = { cell { Text ( \"Column 1\" ) } cell { Text ( \"Column 2\" ) } }) { row { cell { Text ( \"Hello\" ) } cell { CodeBlock ( \"Foo bar\" ) } } row { cell { BlockQuote { Text ( \"Stuff\" ) } } cell { Text ( \"Hello world this is a really long line that is going to wrap hopefully\" ) } } } } Looks like this:","title":"Example"},{"location":"slideshow/","text":"Slideshow \u00b6 A library for presenting simple Powerpoint-like slideshows from a phone (e.g. you can share your phone screen to a Google Hangout and present that way). Slides can contain any composable content, although a few pre-fab scaffolds are provided for common slide layouts. Gradle \u00b6 dependencies { implementation \"com.halilibo.compose-richtext:slideshow:${richtext_version}\" } Setting up a slideshow \u00b6 There is a single, simple entry point to this library, that takes a vararg of composable functions that define your slides: Slideshow ( { /* First slide. */ }, { /* Second slide. */ }, { /* etc\u2026 */ }, ) The Slideshow composable will automatically lock your phone to landscape and enter immersive fullscreen while it's composed. You can tap anywhere on the left or right of the screen to navigate. Currently the only supported slide transition is crossfade, but it shouldn't be hard to make the library more pluggable and support more advanced transition libraries (like this one ). Creating slides \u00b6 Individual slides are centered by default, but you can put whatever you want in them. The library has a few scaffolds for common slide layouts that you might find useful. TitleSlide \u00b6 Very simple: a title and a subtitle, centered. Slideshow ( { TitleSlide ( title = { Text ( \"Title\" ) }, subtitle = { Text ( \"Subtitle\" ) }, ) }, ) BodySlide \u00b6 The BodySlide composable gives you a top header, bottom footer, and middle body slot to put stuff into. Slideshow ( { \u2026 }, { BodySlide ( header = { Text ( \"Header\" ) }, footer = { Text ( \"Footer\" ) }, body = { WebComponent ( \u2026 ) // or something }, ) }, ) Slide scaffolds like BodySlide and TitleSlide , as well as some other aspects of slideshow formatting like background color, are controlled by passing a SlideshowTheme to the Slideshow composable. Animating content on a single slide \u00b6 A corporate presentation wouldn't be a presentation without obtuse visual effects. The NavigableContentContainer composable is a flexible primitive for building such effects. It takes a slot inside of which NavigableContent composables define blocks of content that will be shown or hidden by slide navigation. Each NavigableContent block gets a State<Boolean> indicating whether content should be shown or not, and is free to show or hide content however it likes. For example, Compose comes with the AnimatedVisibility composable out of the box, which plays very nicely with this API. See the SlideshowSample to see it in action. NavigableContentContainer { Column { // Show this right away. Text ( \"First paragraph\" ) // Only show this after tapping to advance the show, then fade it in. NavigableContent { visible -> val opacity = animate ( if ( visible ) 1f else 0f ) Text ( \"Second paragraph\" , Modifier . drawOpacity ( opacity )) } } } Running the show \u00b6 If you're in the middle of a presentation and lose your place, just drag up anywhere on the screen. A slider and preview will pop up to let you scrub through the deck.","title":"Slideshow"},{"location":"slideshow/#slideshow","text":"A library for presenting simple Powerpoint-like slideshows from a phone (e.g. you can share your phone screen to a Google Hangout and present that way). Slides can contain any composable content, although a few pre-fab scaffolds are provided for common slide layouts.","title":"Slideshow"},{"location":"slideshow/#gradle","text":"dependencies { implementation \"com.halilibo.compose-richtext:slideshow:${richtext_version}\" }","title":"Gradle"},{"location":"slideshow/#setting-up-a-slideshow","text":"There is a single, simple entry point to this library, that takes a vararg of composable functions that define your slides: Slideshow ( { /* First slide. */ }, { /* Second slide. */ }, { /* etc\u2026 */ }, ) The Slideshow composable will automatically lock your phone to landscape and enter immersive fullscreen while it's composed. You can tap anywhere on the left or right of the screen to navigate. Currently the only supported slide transition is crossfade, but it shouldn't be hard to make the library more pluggable and support more advanced transition libraries (like this one ).","title":"Setting up a slideshow"},{"location":"slideshow/#creating-slides","text":"Individual slides are centered by default, but you can put whatever you want in them. The library has a few scaffolds for common slide layouts that you might find useful.","title":"Creating slides"},{"location":"slideshow/#titleslide","text":"Very simple: a title and a subtitle, centered. Slideshow ( { TitleSlide ( title = { Text ( \"Title\" ) }, subtitle = { Text ( \"Subtitle\" ) }, ) }, )","title":"TitleSlide"},{"location":"slideshow/#bodyslide","text":"The BodySlide composable gives you a top header, bottom footer, and middle body slot to put stuff into. Slideshow ( { \u2026 }, { BodySlide ( header = { Text ( \"Header\" ) }, footer = { Text ( \"Footer\" ) }, body = { WebComponent ( \u2026 ) // or something }, ) }, ) Slide scaffolds like BodySlide and TitleSlide , as well as some other aspects of slideshow formatting like background color, are controlled by passing a SlideshowTheme to the Slideshow composable.","title":"BodySlide"},{"location":"slideshow/#animating-content-on-a-single-slide","text":"A corporate presentation wouldn't be a presentation without obtuse visual effects. The NavigableContentContainer composable is a flexible primitive for building such effects. It takes a slot inside of which NavigableContent composables define blocks of content that will be shown or hidden by slide navigation. Each NavigableContent block gets a State<Boolean> indicating whether content should be shown or not, and is free to show or hide content however it likes. For example, Compose comes with the AnimatedVisibility composable out of the box, which plays very nicely with this API. See the SlideshowSample to see it in action. NavigableContentContainer { Column { // Show this right away. Text ( \"First paragraph\" ) // Only show this after tapping to advance the show, then fade it in. NavigableContent { visible -> val opacity = animate ( if ( visible ) 1f else 0f ) Text ( \"Second paragraph\" , Modifier . drawOpacity ( opacity )) } } }","title":"Animating content on a single slide"},{"location":"slideshow/#running-the-show","text":"If you're in the middle of a presentation and lose your place, just drag up anywhere on the screen. A slider and preview will pop up to let you scrub through the deck.","title":"Running the show"}]}